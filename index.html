<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ðŸš¤ CanalPilot - Route Calculator</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:Arial,sans-serif;background:linear-gradient(135deg,#74ebd5,#acb6e5);padding:20px;min-height:100vh}
.container{max-width:1600px;margin:0 auto;display:grid;grid-template-columns:1fr 1fr 1fr;gap:20px}
h1{grid-column:1/-1;text-align:center;color:white;font-size:28px;margin-bottom:20px}
.panel{background:white;padding:20px;border-radius:8px;box-shadow:0 4px 15px rgba(0,0,0,0.1)}
h2{color:#333;font-size:18px;margin-bottom:15px;border-bottom:2px solid #007BFF;padding-bottom:10px}
.input-group{margin-bottom:15px}
label{display:block;font-weight:bold;margin-bottom:5px;color:#555;font-size:13px}
.search-box{width:100%;padding:10px;border:2px solid #ddd;border-radius:5px;font-size:14px}
.search-box:focus{outline:none;border-color:#007BFF}
.search-results{position:absolute;background:white;border:2px solid #007BFF;border-top:none;border-radius:0 0 5px 5px;max-height:250px;overflow-y:auto;width:calc(100% - 4px);z-index:100;display:none}
.search-results.show{display:block}
.search-item{padding:8px;cursor:pointer;border-bottom:1px solid #eee;font-size:12px}
.search-item:hover{background:#f0f8ff}
.selected-badge{background:#e8f5e9;padding:8px;border-radius:5px;border-left:4px solid #28a745;font-size:12px;margin-top:8px;display:none}
.selected-badge.show{display:block}
.button-group{display:flex;gap:10px;margin:20px 0}
button{flex:1;padding:10px;background-color:#007BFF;color:white;border:none;border-radius:5px;cursor:pointer;font-weight:bold}
button:hover{background-color:#0056b3}
#map{height:600px;border-radius:8px}
.map-panel{grid-column:2/4;padding:0}
.stats{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin:15px 0}
.stat-box{background:#f0f8ff;padding:12px;border-radius:5px;border-left:4px solid #007BFF;text-align:center}
.stat-label{font-size:11px;color:#666}
.stat-value{font-size:20px;font-weight:bold;color:#007BFF}
.features-list{max-height:400px;overflow-y:auto}
.feature-item{padding:10px;margin:8px 0;background:#f9f9f9;border-left:4px solid #007BFF;border-radius:4px;font-size:12px;cursor:pointer}
.feature-item:hover{background:#f0f0f0}
.badge{display:inline-block;padding:2px 6px;border-radius:10px;color:white;font-size:10px;font-weight:bold;margin-right:5px}
.badge-lock{background:#ff6b6b}
.badge-bridge{background:#4ecdc4}
.badge-marina{background:#45b7d1}
.badge-wharf{background:#96ceb4}
.badge-water{background:#3498db}
.badge-aqueduct{background:#1abc9c}
.badge-tunnel{background:#95a5a6}
.badge-junction{background:#667eea}
.badge-winding_hole{background:#f39c12}
.filter-panel{margin-bottom:12px;padding:8px;background:#f5f5f5;border-radius:5px}
.filter-panel label{font-size:11px;font-weight:normal;cursor:pointer;margin-right:8px;display:inline-flex;align-items:center;gap:2px}
.empty-state{text-align:center;padding:30px 10px;color:#999}
.route-info{background:#e8f5e9;padding:10px;border-radius:5px;margin:10px 0;border-left:4px solid #28a745;font-size:12px}
.search-container{position:relative}
@media (max-width:1200px){
  .container{grid-template-columns:1fr 1fr}
  .map-panel{grid-column:1/-1}
  h1{grid-column:1/-1}
}
</style>
</head>
<body>
<h1>ðŸš¤ CanalPilot - Route Calculator</h1>
<div class="container">
<div class="panel">
<h2>Route Setup</h2>
<div class="input-group">
<label>Start Point:</label>
<div class="search-container">
<input type="text" id="startSearch" class="search-box" placeholder="Type to search...">
<div id="startResults" class="search-results"></div>
</div>
<div id="startBadge" class="selected-badge"></div>
</div>
<div class="input-group">
<label>End Point:</label>
<div class="search-container">
<input type="text" id="endSearch" class="search-box" placeholder="Type to search...">
<div id="endResults" class="search-results"></div>
</div>
<div id="endBadge" class="selected-badge"></div>
</div>
<div id="routeInfo" class="route-info" style="display:none">Distance: <strong id="routeDist">0</strong> mi | Duration: <strong id="routeDur">0</strong></div>
<h2>Calculate</h2>
<div class="input-group">
<label>Speed (mph):</label>
<input type="number" id="speed" value="3" min="0.5" max="10" step="0.5" class="search-box">
</div>
<div class="input-group">
<label>Lookahead (hours):</label>
<input type="number" id="lookahead" value="2" min="0.5" max="24" step="0.5" class="search-box">
</div>
<div class="button-group">
<button onclick="calculateLookahead()">Calculate</button>
<button onclick="resetForm()">Reset</button>
</div>
</div>
<div class="panel">
<h2>Upcoming Features</h2>
<div class="filter-panel">
<strong style="font-size:11px;color:#555;display:block;margin-bottom:4px;">Show:</strong>
<label><input type="checkbox" value="lock" checked onchange="applyFilters()"> Lock</label><label><input type="checkbox" value="bridge" checked onchange="applyFilters()"> Bridge</label><label><input type="checkbox" value="marina" checked onchange="applyFilters()"> Marina</label><label><input type="checkbox" value="wharf" checked onchange="applyFilters()"> Wharf</label><label><input type="checkbox" value="winding_hole" checked onchange="applyFilters()"> Winding Hole</label><label><input type="checkbox" value="water" checked onchange="applyFilters()"> Water</label><label><input type="checkbox" value="aqueduct" checked onchange="applyFilters()"> Aqueduct</label><label><input type="checkbox" value="tunnel" checked onchange="applyFilters()"> Tunnel</label><label><input type="checkbox" value="junction" checked onchange="applyFilters()"> Junction</label>
</div>
<div id="results">
<div class="empty-state">Select start point and click Calculate</div>
</div>
</div>
<div class="panel map-panel">
<div id="map"></div>
</div>
</div>

<script src="testCorridor.js"></script>
<script>
let map;
let markers=[];
let polyline;
let startMarker;
let endMarker;
let routePolyline;
let currentStart=null;
let currentEnd=null;
let crtCanalGeometry=null;
let crtCanalLayer=null;
let overpassCanalLayers=[];
let overpassCanalsData=null;
let leicesterCoords=[];
let lastAllFeatures=[];
let lastMaxDist=0;
let activeFilters=new Set(['lock','bridge','marina','wharf','winding_hole','water','aqueduct','tunnel','junction']);
const FEATURE_COLORS={lock:'#ff6b6b',bridge:'#4ecdc4',marina:'#45b7d1',wharf:'#96ceb4',water:'#3498db',winding_hole:'#f39c12',aqueduct:'#1abc9c',tunnel:'#95a5a6',junction:'#667eea'};

const CRT_ENDPOINTS=[
    'https://services1.arcgis.com/xHoJlKZRLtpEoGqB/arcgis/rest/services/CRT_Navigations/FeatureServer/0/query',
    'https://services1.arcgis.com/xHoJlKZRLtpEoGqB/arcgis/rest/services/Navigations/FeatureServer/0/query',
    'https://services1.arcgis.com/xHoJlKZRLtpEoGqB/arcgis/rest/services/CRT_Waterways/FeatureServer/0/query'
];

const CRT_WHERE_CLAUSES=[
    "NAV_UNIT_NAME LIKE '%Leicester Line%'",
    "name LIKE '%Leicester Line%'",
    "NAVIGATION_NAME LIKE '%Leicester Line%'",
    "NAV_NAME LIKE '%Leicester Line%'"
];

async function fetchCRTCanalGeometry(){
    if(crtCanalGeometry)return crtCanalGeometry;
    for(const endpoint of CRT_ENDPOINTS){
        for(const whereClause of CRT_WHERE_CLAUSES){
            const params=new URLSearchParams({where:whereClause,outFields:'*',returnGeometry:true,f:'geojson'});
            console.log('CRT WFS Query:',{url:endpoint,where:whereClause,timestamp:new Date().toISOString()});
            try{
                const response=await fetch(endpoint+'?'+params);
                if(!response.ok){
                    console.log('CRT WFS Response:',{status:response.status,features:0,timestamp:new Date().toISOString()});
                    console.warn('CRT WFS: HTTP error',response.status,response.statusText);
                    continue;
                }
                const data=await response.json();
                console.log('CRT WFS Response:',{status:response.status,features:data.features?.length||0,timestamp:new Date().toISOString()});
                if(data.error){console.warn('CRT WFS: API error',data.error.message||JSON.stringify(data.error));continue;}
                if(data.features&&data.features.length>0){
                    const coords=[];
                    data.features.forEach(feat=>{
                        if(feat.geometry&&feat.geometry.coordinates){
                            if(feat.geometry.type==='LineString'||feat.geometry.type==='MultiLineString'){
                                const lines=feat.geometry.type==='MultiLineString'?feat.geometry.coordinates:[feat.geometry.coordinates];
                                lines.forEach(line=>line.forEach(c=>coords.push([c[1],c[0]])));
                            }
                        }
                    });
                    if(coords.length>0){
                        crtCanalGeometry=coords;
                        console.log('CRT WFS: Loaded '+coords.length+' coordinates for Leicester Line');
                        return crtCanalGeometry;
                    }
                    console.warn('CRT WFS: Got',data.features.length,'features but no valid geometry');
                }else{
                    console.warn('CRT WFS: No features returned for endpoint',endpoint,'where:',whereClause);
                }
            }catch(e){
                console.warn('CRT WFS: Fetch error for',endpoint+':',e.message);
            }
        }
    }
    console.warn('CRT WFS: All CRT endpoints failed');
    return null;
}

async function fetchOverpassCanalData(){
    if(overpassCanalsData)return overpassCanalsData;
    try{
        const overpassQuery='[out:json][timeout:25];(way["waterway"="canal"]["name"~"Leicester Line|Leicester Navigation"](52.4,-1.25,52.7,-0.9);relation["waterway"="canal"]["name"~"Leicester Line|Leicester Navigation"](52.4,-1.25,52.7,-0.9););out geom;';
        const overpassUrl='https://overpass-api.de/api/interpreter';
        const response=await fetch(overpassUrl,{method:'POST',body:'data='+encodeURIComponent(overpassQuery)});
        console.log('Overpass Response:',{status:response.status,timestamp:new Date().toISOString()});
        if(!response.ok)throw new Error('HTTP '+response.status);
        const data=await response.json();
        if(data.elements&&data.elements.length>0){
            overpassCanalsData={byWayId:{},allCoords:[]};
            data.elements.forEach(el=>{
                if(el.geometry&&el.geometry.length>0){
                    const wayId=el.id;
                    if(!overpassCanalsData.byWayId[wayId]){
                        overpassCanalsData.byWayId[wayId]={name:el.tags?.name||'Canal '+wayId,coords:[]};
                    }
                    el.geometry.forEach(pt=>{
                        const coord=[pt.lat,pt.lon];
                        overpassCanalsData.byWayId[wayId].coords.push(coord);
                        overpassCanalsData.allCoords.push(coord);
                    });
                }
            });
            console.log('Overpass: Loaded '+overpassCanalsData.allCoords.length+' total coordinates across '+Object.keys(overpassCanalsData.byWayId).length+' canals');
            return overpassCanalsData;
        }
        throw new Error('No Leicester Line geometry found');
    }catch(e){
        console.warn('Overpass Leicester Line fetch failed:',e.message,'- falling back to all canals');
        return fetchOverpassAllCanals();
    }
}

async function fetchOverpassAllCanals(){
    try{
        const overpassQuery='[out:json][timeout:25];(way["waterway"="canal"](52.4,-1.25,52.7,-0.9);relation["waterway"="canal"](52.4,-1.25,52.7,-0.9););out geom;';
        const overpassUrl='https://overpass-api.de/api/interpreter';
        const response=await fetch(overpassUrl,{method:'POST',body:'data='+encodeURIComponent(overpassQuery)});
        if(!response.ok)throw new Error('HTTP '+response.status);
        const data=await response.json();
        const canalsData={byWayId:{},allCoords:[]};
        if(data.elements){
            data.elements.forEach(el=>{
                if(el.geometry&&el.geometry.length>0){
                    const wayId=el.id;
                    if(!canalsData.byWayId[wayId]){
                        canalsData.byWayId[wayId]={name:el.tags?.name||'Canal '+wayId,coords:[]};
                    }
                    el.geometry.forEach(pt=>{
                        const coord=[pt.lat,pt.lon];
                        canalsData.byWayId[wayId].coords.push(coord);
                        canalsData.allCoords.push(coord);
                    });
                }
            });
        }
        if(canalsData.allCoords.length>0){
            console.log('Overpass: Loaded '+canalsData.allCoords.length+' coordinates for all canals across '+Object.keys(canalsData.byWayId).length+' canals');
            return canalsData;
        }
        return null;
    }catch(e){
        console.warn('Overpass all canals fetch failed:',e.message);
        return null;
    }
}

function drawOverpassCanals(canalsData){
    if(!canalsData||!canalsData.byWayId)return;
    leicesterCoords=[];
    // Phase 1: Draw all non-Leicester canals as gray lines
    Object.keys(canalsData.byWayId).forEach(wayId=>{
        const canal=canalsData.byWayId[wayId];
        if(canal.coords.length>0){
            const isLeicesterLine=canal.name.toLowerCase().includes('leicester');
            if(isLeicesterLine){
                leicesterCoords.push(canal.coords);
            }else{
                L.polyline(canal.coords,{
                    color:'#6b7280',
                    weight:2,
                    opacity:0.6,
                    lineCap:'round',
                    lineJoin:'round'
                }).addTo(map);
            }
        }
    });
    // Phase 2: Draw Leicester Line LAST so it renders on top
    if(leicesterCoords.length>0){
        const flatCoords=leicesterCoords.flat();
        const leicesterLayer=L.polyline(flatCoords,{
            color:'#2563eb',
            weight:4,
            opacity:0.85,
            lineCap:'round',
            lineJoin:'round'
        }).addTo(map);
        leicesterLayer.bringToFront();
        console.log('Drew Leicester Line as single polyline with '+flatCoords.length+' coordinates');
    }
}

async function initMap(){
    map=L.map('map').setView([52.36,-1.1],10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'Â© OpenStreetMap',maxZoom:19}).addTo(map);
    setupSearch('startSearch','startResults','startBadge','start');
    setupSearch('endSearch','endResults','endBadge','end');
    const crtCoords=await fetchCRTCanalGeometry();
    if(crtCoords){
        console.log('Using CRT canal geometry');
        crtCanalLayer=L.polyline(crtCoords,{color:'#4a90d9',weight:3,opacity:0.7}).addTo(map);
        return;
    }
    const canalsData=await fetchOverpassCanalData();
    if(canalsData&&Object.keys(canalsData.byWayId).length>0){
        console.log('Using Overpass canal geometry');
        drawOverpassCanals(canalsData);
        return;
    }
    console.warn('Both CRT and Overpass failed, no base layer drawn');
}

function setupSearch(inputId,resultsId,badgeId,type){
    const input=document.getElementById(inputId);
    const resultsDiv=document.getElementById(resultsId);
    input.addEventListener('input',function(){
        const query=this.value.toLowerCase();
        resultsDiv.innerHTML='';
        if(query.length===0){
            resultsDiv.classList.remove('show');
            return;
        }
        const filtered=testCorridor.features.filter(f=>f.name.toLowerCase().includes(query)).slice(0,15);
        if(filtered.length===0){
            resultsDiv.innerHTML='<div class="search-item" style="color:#999;">No matches</div>';
        }else{
            filtered.forEach(f=>{
                const item=document.createElement('div');
                item.className='search-item';
                item.textContent=f.name+' ('+f.cumulativeDistance.toFixed(1)+' mi)';
                item.onclick=function(){selectFeature(f,type,inputId,badgeId);};
                resultsDiv.appendChild(item);
            });
        }
        resultsDiv.classList.add('show');
    });
    document.addEventListener('click',function(e){
        if(!e.target.closest('.search-container')){
            resultsDiv.classList.remove('show');
        }
    });
}

function selectFeature(feature,type,inputId,badgeId){
    const input=document.getElementById(inputId);
    const badge=document.getElementById(badgeId);
    input.value=feature.name;
    badge.innerHTML='âœ“ <strong>'+feature.name+'</strong><br>'+feature.cumulativeDistance.toFixed(1)+' mi';
    badge.classList.add('show');
    document.getElementById(inputId.replace('Search','Results')).classList.remove('show');
    if(type==='start'){
        currentStart=feature;
        addStartMarker();
    }else{
        currentEnd=feature;
        addEndMarker();
    }
}

function addStartMarker(){
    if(currentStart){
        if(startMarker)map.removeLayer(startMarker);
        startMarker=L.circleMarker([currentStart.latitude,currentStart.longitude],{radius:10,fillColor:'#28a745',color:'white',weight:2,fillOpacity:0.9}).bindPopup('START: '+currentStart.name).addTo(map);
        updateRoute();
    }
}

function addEndMarker(){
    if(currentEnd){
        if(endMarker)map.removeLayer(endMarker);
        endMarker=L.circleMarker([currentEnd.latitude,currentEnd.longitude],{radius:10,fillColor:'#dc3545',color:'white',weight:2,fillOpacity:0.9}).bindPopup('END: '+currentEnd.name).addTo(map);
        updateRoute();
    }
}

function updateRoute(){
    if(currentStart&&currentEnd){
        if(routePolyline)map.removeLayer(routePolyline);
        const dist=Math.abs(currentEnd.cumulativeDistance-currentStart.cumulativeDistance);
        const speed=parseFloat(document.getElementById('speed').value)||3;
        const hours=Math.floor(dist/speed);
        const mins=Math.round((dist/speed-hours)*60);
        const timeStr=hours>0?hours+'h '+mins+'m':mins+'m';
        document.getElementById('routeDist').textContent=dist.toFixed(1);
        document.getElementById('routeDur').textContent=timeStr;
        document.getElementById('routeInfo').style.display='block';
        const minDist=Math.min(currentStart.cumulativeDistance,currentEnd.cumulativeDistance);
        const maxDist=Math.max(currentStart.cumulativeDistance,currentEnd.cumulativeDistance);
        const pathCoords=testCorridor.features.filter(f=>f.cumulativeDistance>=minDist&&f.cumulativeDistance<=maxDist).sort((a,b)=>a.cumulativeDistance-b.cumulativeDistance).map(f=>[f.latitude,f.longitude]);
        routePolyline=L.polyline(pathCoords,{color:'#28a745',weight:4,opacity:0.8}).addTo(map);
    }
}

function getFeatureType(f){
    if(f.type==='water'&&f.name.toLowerCase().includes('winding hole'))return 'winding_hole';
    return f.type;
}

function applyFilters(){
    activeFilters=new Set();
    document.querySelectorAll('.filter-panel input[type=checkbox]').forEach(cb=>{
        if(cb.checked)activeFilters.add(cb.value);
    });
    renderFeatures();
}

function renderFeatures(){
    const resultDiv=document.getElementById('results');
    if(!currentStart||lastAllFeatures.length===0){
        resultDiv.innerHTML='<div class="empty-state">Select start point and click Calculate</div>';
        return;
    }
    const speed=parseFloat(document.getElementById('speed').value);
    const features=lastAllFeatures.filter(f=>activeFilters.has(getFeatureType(f)));
    resultDiv.innerHTML='';
    if(features.length===0){
        resultDiv.innerHTML='<div class="empty-state">No features match the current filters</div>';
        markers.forEach(m=>map.removeLayer(m));
        markers=[];
        return;
    }
    const locks=features.filter(f=>getFeatureType(f)==='lock').length;
    const bridges=features.filter(f=>getFeatureType(f)==='bridge').length;
    const marinas=features.filter(f=>getFeatureType(f)==='marina').length;
    let html='<div class="stats"><div class="stat-box"><div class="stat-label">Ahead</div><div class="stat-value">'+features.length+'</div></div>';
    html+='<div class="stat-box"><div class="stat-label">Locks</div><div class="stat-value">'+locks+'</div></div>';
    html+='<div class="stat-box"><div class="stat-label">Bridges</div><div class="stat-value">'+bridges+'</div></div>';
    html+='<div class="stat-box"><div class="stat-label">Marinas</div><div class="stat-value">'+marinas+'</div></div></div>';
    html+='<div class="features-list">';
    features.forEach(f=>{
        const ft=getFeatureType(f);
        const eta=(f.cumulativeDistance-currentStart.cumulativeDistance)/speed;
        const h=Math.floor(eta);
        const m=Math.round((eta-h)*60);
        const timeStr=h>0?h+'h '+m+'m':m+'m';
        html+='<div class="feature-item" onclick="map.setView(['+f.latitude+','+f.longitude+'],14)">';
        html+='<span class="badge badge-'+ft+'">'+ft.replace('_',' ').toUpperCase()+'</span>';
        html+='<strong>'+f.name+'</strong><br>';
        html+='<small>'+f.cumulativeDistance.toFixed(1)+' mi | ETA: '+timeStr+'</small>';
        html+='</div>';
    });
    html+='</div>';
    resultDiv.innerHTML=html;
    markers.forEach(m=>map.removeLayer(m));
    markers=[];
    features.forEach(f=>{
        const ft=getFeatureType(f);
        const m=L.circleMarker([f.latitude,f.longitude],{radius:6,fillColor:FEATURE_COLORS[ft]||'#007BFF',color:'white',weight:1,fillOpacity:0.8}).bindPopup(f.name).addTo(map);
        markers.push(m);
    });
}

function calculateLookahead(){
    if(!currentStart){
        alert('Select a start point');
        return;
    }
    const speed=parseFloat(document.getElementById('speed').value);
    const hours=parseFloat(document.getElementById('lookahead').value);
    const distance=speed*hours;
    lastMaxDist=currentStart.cumulativeDistance+distance;
    lastAllFeatures=testCorridor.features.filter(f=>f.cumulativeDistance>currentStart.cumulativeDistance&&f.cumulativeDistance<=lastMaxDist).sort((a,b)=>a.cumulativeDistance-b.cumulativeDistance);
    clearMarkers();
    let pathCoords=[];
    if(crtCanalGeometry&&crtCanalGeometry.length>0){
        pathCoords=crtCanalGeometry;
    }else if(leicesterCoords.length>0){
        pathCoords=leicesterCoords.flat();
    }else{
        pathCoords=testCorridor.features.filter(f=>f.cumulativeDistance>=currentStart.cumulativeDistance&&f.cumulativeDistance<=lastMaxDist).sort((a,b)=>a.cumulativeDistance-b.cumulativeDistance).map(f=>[f.latitude,f.longitude]);
    }
    if(pathCoords.length>0){
        // polyline=L.polyline(pathCoords,{color:'#667eea',weight:4,opacity:0.9}).addTo(map);
        const allCoords=pathCoords.slice();
        if(currentEnd)allCoords.push([currentEnd.latitude,currentEnd.longitude]);
        const bounds=L.latLngBounds(allCoords);
        map.fitBounds(bounds,{padding:[50,50]});
    }
    renderFeatures();
}

function clearMarkers(){
    markers.forEach(m=>map.removeLayer(m));
    markers=[];
    if(polyline)map.removeLayer(polyline);
    if(routePolyline)map.removeLayer(routePolyline);
}

function resetForm(){
    document.getElementById('startSearch').value='';
    document.getElementById('endSearch').value='';
    document.getElementById('startBadge').classList.remove('show');
    document.getElementById('endBadge').classList.remove('show');
    document.getElementById('speed').value='3';
    document.getElementById('lookahead').value='2';
    document.getElementById('results').innerHTML='<div class="empty-state">Select start point and click Calculate</div>';
    document.getElementById('routeInfo').style.display='none';
    currentStart=null;
    currentEnd=null;
    clearMarkers();
    if(startMarker)map.removeLayer(startMarker);
    if(endMarker)map.removeLayer(endMarker);
}

window.onload=function(){initMap();};
</script>
</body>
</html>
