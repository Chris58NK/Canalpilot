<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>CanalPilot Engine Test</title>
</head>
<body>
  <h2>CanalPilot â€“ Routing Engine Proof</h2>
  <pre id="output"></pre>

  <script>
    const out = document.getElementById("output");

    // --- Fake corridor dataset (proof of concept) ---
    const corridor = {
      id: "test_corridor",
      length: 3200, // meters
      features: [
        { type: "lock", name: "Lock A", chainage: 800 },
        { type: "lock", name: "Lock B", chainage: 1600 },
        { type: "winding", name: "Winding Hole", chainage: 2400 },
        { type: "lock", name: "Lock C", chainage: 3200 }
      ]
    };

    function getNextFeature(start, end) {
      const northbound = end > start;
      const candidates = corridor.features.filter(f =>
        northbound ? f.chainage > start : f.chainage < start
      );
      if (candidates.length === 0) return null;

      return northbound
        ? candidates.sort((a, b) => a.chainage - b.chainage)[0]
        : candidates.sort((a, b) => b.chainage - a.chainage)[0];
    }

    function calculateRoute(start, end, speedMph = 3, minutesPerLock = 8) {
      const distanceMeters = Math.abs(end - start);
      const distanceMiles = distanceMeters / 1609.344;

      const locks = corridor.features.filter(f =>
        f.type === "lock" &&
        f.chainage > Math.min(start, end) &&
        f.chainage <= Math.max(start, end)
      );

      const cruisingHours = distanceMiles / speedMph;
      const lockHours = (locks.length * minutesPerLock) / 60;

      return {
        direction: end > start ? "Northbound" : "Southbound",
        startChainage: start,
        endChainage: end,
        distanceMiles: distanceMiles.toFixed(2),
        lockCount: locks.length,
        etaHours: (cruisingHours + lockHours).toFixed(2),
        nextFeature: getNextFeature(start, end)
      };
    }

    function featuresWithinHours(start, end, hours, speedMph) {
      const northbound = end > start;
      const rangeMeters = speedMph * 1609.344 * hours;
      const limit = northbound ? (start + rangeMeters) : (start - rangeMeters);

      const items = corridor.features.filter(f =>
        northbound
          ? (f.chainage > start && f.chainage <= limit)
          : (f.chainage < start && f.chainage >= limit)
      );

      items.sort((a, b) =>
        northbound ? a.chainage - b.chainage : b.chainage - a.chainage
      );

      return {
        direction: northbound ? "Northbound" : "Southbound",
        windowHours: hours,
        speedMph,
        startChainage: start,
        limitChainage: limit,
        items
      };
    }

    // --- Test Runs ---
    const speedMph = 3;
    const minutesPerLock = 8;
    const windowHours = 1;

    const northboundResult = calculateRoute(0, 3200, speedMph, minutesPerLock);
    const southboundResult = calculateRoute(3200, 0, speedMph, minutesPerLock);

    const northWindow = featuresWithinHours(0, 3200, windowHours, speedMph);
    const southWindow = featuresWithinHours(3200, 0, windowHours, speedMph);

    out.textContent =
      "Northbound route:\n" +
      JSON.stringify(northboundResult, null, 2) +
      "\n\nSouthbound route:\n" +
      JSON.stringify(southboundResult, null, 2) +
      `\n\nFeatures within next ${windowHours} hour(s) at ${speedMph} mph (Northbound):\n` +
      JSON.stringify(northWindow, null, 2) +
      `\n\nFeatures within next ${windowHours} hour(s) at ${speedMph} mph (Southbound):\n` +
      JSON.stringify(southWindow, null, 2);
  </script>
</body>
</html>
