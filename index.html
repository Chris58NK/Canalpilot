<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>ðŸš¤ CanalPilot - Route Calculator</title><link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" /><script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script><style>*{margin:0;padding:0;box-sizing:border-box}body{font-family:Arial,sans-serif;background:linear-gradient(135deg,#74ebd5,#acb6e5);padding:20px;min-height:100vh}.container{max-width:1600px;margin:0 auto;display:grid;grid-template-columns:1fr 1fr 1fr;gap:20px}h1{grid-column:1/-1;text-align:center;color:white;font-size:28px;margin-bottom:20px}.panel{background:white;padding:20px;border-radius:8px;box-shadow:0 4px 15px rgba(0,0,0,0.1)}h2{color:#333;font-size:18px;margin-bottom:15px;border-bottom:2px solid #007BFF;padding-bottom:10px}.input-group{margin-bottom:15px}label{display:block;font-weight:bold;margin-bottom:5px;color:#555;font-size:13px}.search-box{width:100%;padding:10px;border:2px solid #ddd;border-radius:5px;font-size:14px}.search-box:focus{outline:none;border-color:#007BFF}.search-results{position:absolute;background:white;border:2px solid #007BFF;border-top:none;border-radius:0 0 5px 5px;max-height:250px;overflow-y:auto;width:calc(100% - 4px);z-index:100;display:none}.search-results.show{display:block}.search-item{padding:8px;cursor:pointer;border-bottom:1px solid #eee;font-size:12px}.search-item:hover{background:#f0f8ff}.selected-badge{background:#e8f5e9;padding:8px;border-radius:5px;border-left:4px solid #28a745;font-size:12px;margin-top:8px;display:none}.selected-badge.show{display:block}.button-group{display:flex;gap:10px;margin:20px 0}button{flex:1;padding:10px;background-color:#007BFF;color:white;border:none;border-radius:5px;cursor:pointer;font-weight:bold}button:hover{background-color:#0056b3}#map{height:600px;border-radius:8px}.map-panel{grid-column:2/4;padding:0}.stats{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin:15px 0}.stat-box{background:#f0f8ff;padding:12px;border-radius:5px;border-left:4px solid #007BFF;text-align:center}.stat-label{font-size:11px;color:#666}.stat-value{font-size:20px;font-weight:bold;color:#007BFF}.features-list{max-height:400px;overflow-y:auto}.feature-item{padding:10px;margin:8px 0;background:#f9f9f9;border-left:4px solid #007BFF;border-radius:4px;font-size:12px;cursor:pointer}.feature-item:hover{background:#f0f0f0}.badge{display:inline-block;padding:2px 6px;border-radius:10px;color:white;font-size:10px;font-weight:bold;margin-right:5px}.badge-lock{background:#ff6b6b}.badge-bridge{background:#4ecdc4}.badge-marina{background:#45b7d1}.badge-wharf{background:#96ceb4}.badge-water{background:#3498db}.badge-tunnel{background:#95a5a6}.badge-junction{background:#667eea}.empty-state{text-align:center;padding:30px 10px;color:#999}.route-info{background:#e8f5e9;padding:10px;border-radius:5px;margin:10px 0;border-left:4px solid #28a745;font-size:12px}.search-container{position:relative}@media (max-width:1200px){.container{grid-template-columns:1fr 1fr}.map-panel{grid-column:1/-1}h1{grid-column:1/-1}}</style></head><body><h1>ðŸš¤ CanalPilot - Route Calculator</h1><div class="container"><div class="panel"><h2>Route Setup</h2><div class="input-group"><label>Start Point:</label><div class="search-container"><input type="text" id="startSearch" class="search-box" placeholder="Type to search..."><div id="startResults" class="search-results"></div></div><div id="startBadge" class="selected-badge"></div></div><div class="input-group"><label>End Point:</label><div class="search-container"><input type="text" id="endSearch" class="search-box" placeholder="Type to search..."><div id="endResults" class="search-results"></div></div><div id="endBadge" class="selected-badge"></div></div><div id="routeInfo" class="route-info" style="display:none">Distance: <strong id="routeDist">0</strong> mi | Duration: <strong id="routeDur">0</strong></div><h2>Calculate</h2><div class="input-group"><label>Speed (mph):</label><input type="number" id="speed" value="3" min="0.5" max="10" step="0.5" class="search-box"></div><div class="input-group"><label>Lookahead (hours):</label><input type="number" id="lookahead" value="2" min="0.5" max="24" step="0.5" class="search-box"></div><div class="button-group"><button onclick="calculateLookahead()">Calculate</button><button onclick="resetForm()">Reset</button></div></div><div class="panel"><h2>Upcoming Features</h2><div id="results"><div class="empty-state">Select start point and click Calculate</div></div></div><div class="panel map-panel"><div id="map"></div></div></div><script src="testCorridor.js"></script><script>let map;let markers=[];let polyline;let startMarker;let endMarker;let routePolyline;let currentStart=null;let currentEnd=null;
// Ordered list of CRT FeatureServer endpoints to try (most likely correct first)
const CRT_ENDPOINTS=[
    'https://services1.arcgis.com/xHoJlKZRLtpEoGqB/arcgis/rest/services/CRT_Navigations/FeatureServer/0/query',
    'https://services1.arcgis.com/xHoJlKZRLtpEoGqB/arcgis/rest/services/Navigations/FeatureServer/0/query',
    'https://services1.arcgis.com/xHoJlKZRLtpEoGqB/arcgis/rest/services/CRT_Waterways/FeatureServer/0/query'
];
// WHERE clauses using candidate field names for the Leicester Line
const CRT_WHERE_CLAUSES=[
    "NAV_UNIT_NAME LIKE '%Leicester Line%'",
    "name LIKE '%Leicester Line%'",
    "NAVIGATION_NAME LIKE '%Leicester Line%'",
    "NAV_NAME LIKE '%Leicester Line%'"
];
 let crtCanalGeometry=null;let crtCanalLayer=null;let overpassCanalLayers=[];let overpassCanalsData=null;async function fetchCRTCanalGeometry(){
    if(crtCanalGeometry)return crtCanalGeometry;
    // Primary: Try CRT ArcGIS endpoints
    for(const endpoint of CRT_ENDPOINTS){
        for(const whereClause of CRT_WHERE_CLAUSES){
            const params=new URLSearchParams({where:whereClause,outFields:'*',returnGeometry:true,f:'geojson'});
            console.log('CRT WFS Query:',{url:endpoint,where:whereClause,timestamp:new Date().toISOString()});
            try{
                const response=await fetch(endpoint+'?'+params);
                if(!response.ok){
                    console.log('CRT WFS Response:',{status:response.status,features:0,timestamp:new Date().toISOString()});
                    console.warn('CRT WFS: HTTP error',response.status,response.statusText);
                    continue;
                }
                const data=await response.json();
                console.log('CRT WFS Response:',{status:response.status,features:data.features?.length||0,timestamp:new Date().toISOString()});
                if(data.error){console.warn('CRT WFS: API error',data.error.message||JSON.stringify(data.error));continue;}
                if(data.features&&data.features.length>0){
                    const coords=[];
                    data.features.forEach(feat=>{
                        if(feat.geometry&&feat.geometry.coordinates){
                            if(feat.geometry.type==='LineString'||feat.geometry.type==='MultiLineString'){
                                const lines=feat.geometry.type==='MultiLineString'?feat.geometry.coordinates:[feat.geometry.coordinates];
                                /* GeoJSON uses [lng,lat]; Leaflet needs [lat,lng] */
                                lines.forEach(line=>line.forEach(c=>coords.push([c[1],c[0]])));
                            }
                        }
                    });
                    if(coords.length>0){
                        crtCanalGeometry=coords;
                        console.log('CRT WFS: Loaded '+coords.length+' coordinates for Leicester Line');
                        return crtCanalGeometry;
                    }
                    console.warn('CRT WFS: Got',data.features.length,'features but no valid geometry');
                }else{
                    console.warn('CRT WFS: No features returned for endpoint',endpoint,'where:',whereClause);
                }
            }catch(e){
                console.warn('CRT WFS: Fetch error for',endpoint+':',e.message);
            }
        }
    }
    console.warn('CRT WFS: All CRT endpoints failed');
    return null;
}

 async function fetchOverpassCanalData(){
    if(overpassCanalsData)return overpassCanalsData;
    try{
        const overpassQuery='[out:json][timeout:25];(way["waterway"="canal"]["name"~"Leicester Line|Leicester Navigation"](52.4,-1.25,52.7,-0.9);relation["waterway"="canal"]["name"~"Leicester Line|Leicester Navigation"](52.4,-1.25,52.7,-0.9););out geom;';
        const overpassUrl='https://overpass-api.de/api/interpreter';
        const response=await fetch(overpassUrl,{method:'POST',body:'data='+encodeURIComponent(overpassQuery)});
        console.log('Overpass Response:',{status:response.status,timestamp:new Date().toISOString()});
        if(!response.ok)throw new Error('HTTP '+response.status);
        const data=await response.json();
        if(data.elements&&data.elements.length>0){
            overpassCanalsData={byWayId:{},allCoords:[]};
            data.elements.forEach(el=>{
                if(el.geometry&&el.geometry.length>0){
                    const wayId=el.id;
                    if(!overpassCanalsData.byWayId[wayId]){
                        overpassCanalsData.byWayId[wayId]={name:el.tags?.name||'Canal '+wayId,coords:[]};
                    }
                    el.geometry.forEach(pt=>{
                        const coord=[pt.lat,pt.lon];
                        overpassCanalsData.byWayId[wayId].coords.push(coord);
                        overpassCanalsData.allCoords.push(coord);
                    });
                }
            });
            console.log('Overpass: Loaded '+overpassCanalsData.allCoords.length+' total coordinates across '+Object.keys(overpassCanalsData.byWayId).length+' canals');
            return overpassCanalsData;
        }
        throw new Error('No Leicester Line geometry found');
    }catch(e){
        console.warn('Overpass Leicester Line fetch failed:',e.message,'- falling back to all canals');
        return fetchOverpassAllCanals();
    }
}

async function fetchOverpassAllCanals(){
    try{
        const overpassQuery='[out:json][timeout:25];(way["waterway"="canal"](52.4,-1.25,52.7,-0.9);relation["waterway"="canal"](52.4,-1.25,52.7,-0.9););out geom;';
        const overpassUrl='https://overpass-api.de/api/interpreter';
        const response=await fetch(overpassUrl,{method:'POST',body:'data='+encodeURIComponent(overpassQuery)});
        if(!response.ok)throw new Error('HTTP '+response.status);
        const data=await response.json();
        const canalsData={byWayId:{},allCoords:[]};
        if(data.elements){
            data.elements.forEach(el=>{
                if(el.geometry&&el.geometry.length>0){
                    const wayId=el.id;
                    if(!canalsData.byWayId[wayId]){
                        canalsData.byWayId[wayId]={name:el.tags?.name||'Canal '+wayId,coords:[]};
                    }
                    el.geometry.forEach(pt=>{
                        const coord=[pt.lat,pt.lon];
                        canalsData.byWayId[wayId].coords.push(coord);
                        canalsData.allCoords.push(coord);
                    });
                }
            });
        }
        if(canalsData.allCoords.length>0){
            console.log('Overpass: Loaded '+canalsData.allCoords.length+' coordinates for all canals across '+Object.keys(canalsData.byWayId).length+' canals');
            return canalsData;
        }
        return null;
    }catch(e){
        console.warn('Overpass all canals fetch failed:',e.message);
        return null;
    }
}

function drawOverpassCanals(canalsData){
    if(!canalsData||!canalsData.byWayId)return;
    Object.keys(canalsData.byWayId).forEach(wayId=>{
        const canal=canalsData.byWayId[wayId];
        if(canal.coords.length>0){
            const isLeicesterLine=canal.name.toLowerCase().includes('leicester');
            const polyline=L.polyline(canal.coords,{
                color:isLeicesterLine?'#2563eb':'#6b7280',
                weight:isLeicesterLine?4:2,
                opacity:isLeicesterLine?0.85:0.6,
                lineCap:'round',
                lineJoin:'round'
            }).addTo(map);
            overpassCanalLayers.push(polyline);
            if(isLeicesterLine){
                console.log('Drew Leicester Line with '+canal.coords.length+' coordinates');
            }else{
                console.log('Drew '+canal.name+' with '+canal.coords.length+' coordinates');
            }
        }
    });
}  
